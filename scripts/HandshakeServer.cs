using System;
using System.Collections;
using System.Collections.Generic;
using System.Text;
using Godot;
using MessagePack;

//uses a WebSocketServer to allow new peers to connect to self
//Once the peer is connected to us,
//We use the WebRTC mesh to do the rest of the signalling.
public class HandshakeServer : Node
{
    //reference to the parent for when we need to
    //tell it we have authenticated clients.
    private Networking networking;
    //exclusively used to complete the handshake phase.
    private class WSPeer{
        
        public int uid;
        public float Time;
        public bool Authenticated;
        public bool Success;

        public WSPeer(int _uid, float time){
            //This is the ID generated by Networking
            //which is separate from the internal ID 
            uid = _uid;
            Time = time;
            Authenticated = false;
            Success = false;
            
        }
    }

    public Random rnd = new Random();

    public const int TIMEOUT = 2000;
    public const int PORT = 3476;
    public string secret; //in practice, this is set by the user.
    public WebSocketServer server = new WebSocketServer();
    
    private Dictionary<int, WSPeer> WSPeers = new Dictionary<int, WSPeer>();

    //maps WebRTCMultiplayer.GetUniqueID() to WebSocketServer ID.
    //needed for when offers and iceCandidates are generated and need
    //to be sent to the right WebSocketClient.
    private Dictionary<int, int> WSIDMap = new Dictionary<int, int>();

    
    public override void _Ready()
    {
        SetProcess(false);
        this.networking = (Networking) GetNode("..");
        
        server.Connect("data_received", this, "_OnData");
        server.Connect("client_connected", this, "_PeerConnected");
        server.Connect("client_disconnected", this, "_PeerDisconnected");

    }

    public void _StartServer(string _secret)
    {
        server.Listen(PORT);
        
        WSPeers = new Dictionary<int, WSPeer>();
        WSIDMap = new Dictionary<int, int>();
        secret = _secret;
        SetProcess(true);
    }

    public void _StopServer()
    {
        SetProcess(false);
        server.Stop();
        //Now we need to remove all the peers
        //that haven't connected through WebRTC yet.

        foreach(KeyValuePair<int, WSPeer> p in WSPeers)
        {
            networking.SignaledPeers.Remove(p.Value.uid);
            server.DisconnectPeer(p.Key, reason: "Server Stopped");   
        }
        //Null out dicts tracking peers.
        //probably better to do each individually to catch errors better,
        //but I'm tired rn.
        WSPeers = null;
        WSIDMap = null;
        
    }

    public void _PeerConnected(int id, String protocol = "")
    {
        GD.Print("_PeerConnected", id);
        WSPeers.Add(id, new WSPeer(-1, OS.GetTicksMsec()));
    }
    
    //When we either time someone out, they disconnect on their own,
    //or they disconnect because they've set up the WebRTC connection,
    //this gets called.
    public void _PeerDisconnected(int id, bool wasCleanClose)
    {
        GD.Print("_PeerDisconnected");
        
        //If the peer is connected, we can transfer it over to Networking
        //Otherwise, close the connection and delete the peer.
        int uid = WSPeers[id].uid;
        SignaledPeer peer = networking.SignaledPeers[uid];

        if( peer.currentState == SignaledPeer.ConnectionState.NOMINAL)
        {
            peer.PeerConnection.Disconnect("session_description_created",this,"_OfferCreated");
            peer.PeerConnection.Disconnect("ice_candidate_created",this,"_IceCandidateCreated");
        }
        else
        {
            networking.SignaledPeers.Remove(uid);
        }
    
        // In both cases, remove them from the Websocket dictionaries
        // since that connection no longer exists.
        WSIDMap.Remove(WSPeers[id].uid);
        WSPeers.Remove(id);
    }

    //Any connection we're still in charge of should only generate answers.
    public void _OfferCreated(String type, String sdp, int uid)
    {
        GD.Print("_OfferCreated");

        networking.SignaledPeers[uid].SetLocalDescription(type,sdp);
        
        //Make a serializeable offer
        var offerDict = new Dictionary<string,dynamic>();
        offerDict.Add("type",type);
        offerDict.Add("sdp",sdp);
        byte[] payload =  MessagePackSerializer.Serialize(offerDict);
        server.GetPeer(WSIDMap[uid]).PutPacket(payload);
    }

    public void _IceCandidateCreated(string media, int index, string name, int uid)
    {
        var iceDict = new Dictionary<string,dynamic>();
        iceDict.Add("type","iceCandidate");
        //this is our ID we're sending them, not the id we have them registered under
        iceDict.Add("uid",networking.RTCMP.GetUniqueId());
        iceDict.Add("media",media);
        iceDict.Add("index",index);
        iceDict.Add("name", name);
        byte[] payload =  MessagePackSerializer.Serialize(iceDict);

        //the id here is the WebRTC id, not WebSocket id, so it needs
        //to be translated to send the packet to the right WebSocketClient.
        server.GetPeer(WSIDMap[uid]).PutPacket(payload);
    }

    private int GenUniqueID()
    {
        int candidate = rnd.Next(1,2147483647);

        //will almost certainly never happen
        //but in case it does, this guarantees a unique ID if one is available.
        //(God help you if you're playing with 2 billion+ people and one isn't available.)
        while(networking.RTCMP.HasPeer(candidate))
        {
            if(candidate==2147483647)
                candidate = 1;
            else
                candidate++;
        }
        return candidate;
    }

    //id is for the websocket
    //uid is for the WebRTCMultiplayer UniqueID.
    public void _OnData(int id)
    {
        GD.Print("_OnData");
        byte[] rawPacket = server.GetPeer(id).GetPacket();
        GD.Print(rawPacket.GetLength(0));
        GD.Print(MessagePackSerializer.ConvertToJson(rawPacket));
        GD.Print();
        Dictionary<string, dynamic> data = MessagePackSerializer.Deserialize<Dictionary<string,dynamic>>(rawPacket);
        
        if(WSPeers[id].Authenticated)
        {
            //once the peer is authenticated, we can start talking to them
            ParseHandshake(data);
        }
        else
        {
            GD.Print("Trying to authenticate");
            
            if(data["type"]=="authentication" && data["secret"] == "secret")
            {
                //Add it as a WebRTCPeerConnection.

                int newUID = GenUniqueID();
                WSPeers[id].uid = newUID;
                
                SignaledPeer newPeer = new SignaledPeer(newUID, networking, SignaledPeer.ConnectionState.MANUAL, networking.PollTimer);
                networking.SignaledPeers.Add(newUID, newPeer);
                newPeer.PeerConnection.Connect("session_description_created", this, "_OfferCreated", SignaledPeer.intToGArr(newUID));
                newPeer.PeerConnection.Connect("ice_candidate_created", this, "_IceCandidateCreated",SignaledPeer.intToGArr(newUID));
                WSIDMap.Add(newUID,id);

                //Tell the peer that they've authenticated successfully.
                WSPeers[id].Authenticated = true;

                var authDict = new Dictionary<string, dynamic>();
                authDict["type"] = "authentication";
                authDict["status"] = "success";
                authDict["assignedUID"] = newUID; //the uid that we're assigning them
                authDict["uid"] = networking.RTCMP.GetUniqueId();//our uid
                byte[] authPayload = MessagePackSerializer.Serialize(authDict);
                server.GetPeer(id).PutPacket(authPayload);
                
            }
            else
            {
                GD.Print("Authentication failed");
            }
        }
    }

    private void ParseHandshake(Dictionary<string,dynamic> data)
    {
        
        //once again needing to cast data["uid"] from uint32 to int
        SignaledPeer peer = networking.SignaledPeers[(int) data["uid"]];
        GD.Print(data["uid"]);
        if(data["type"]=="offer")
            peer.SetRemoteDescription(data["type"],data["sdp"]);
        else if (data["type"] == "iceCandidate")
            networking.SignaledPeers[(int) data["uid"]].BufferIceCandidate(data["media"], (int) data["index"],data["name"]);   
    }
    public override void _Process(float delta)
    {
        server.Poll();

        //For timing out peers that may have connectivity trouble
        //during the handshake phase.
        foreach(KeyValuePair<int, WSPeer> p in WSPeers)
        {
            if( !p.Value.Success && OS.GetTicksMsec() - p.Value.Time > TIMEOUT)
            {
                GD.Print("Timing Out");
                GD.Print(p.Key);
                //This should trigger the client_disconnected signal
                //which should trigger the removal of the correct objects
                //from the relevant arrays.
                server.DisconnectPeer(p.Key, reason: "WebSocket TIMEOUT");   
            }
        }
    }
}
